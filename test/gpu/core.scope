'use strict';


module.exports = {
	
	MAX: 1000,
	
	pos   : 'float2', // позиция
	rgb   : 'float3', // цвет
	size  : 'float' , // relative size
	energy: 'float' , // energy storage
	food  : 'float' , // energy storage
	
	fov2  : 'float',
	
	// dynamics
	dir: 'float2',
	vel: 'float2',
	
	eyes: 'int' , // number of eyes
	eyes2: ['Eye'],
	
	clockwise: 'Ns.Neuron',
	forward  : 'Ns.Neuron',
	right    : 'Ns.Neuron',
	fov      : 'Ns.Neuron',
	
	
	'void ctor(float2 pos)': `
	
		.pos    = pos;
		.rgb    = {0.3f, 0.3f, 0.3f};
		.size   = 16.0f;
		.energy = 1.0f;
		.eyes   = 10;
		.food   = 0;
		.fov2   = 0.0f;
		
		.vel    = {0.0f, 0.0f};
		for (int j = 0; j < .%100; j++) {
			Random.get();
		}
		
		float dirPhi = Random.get() * 6.28;
		.dir = {sin(dirPhi), cos(dirPhi)};
		
	`,
	
	
	add(count, pos, scale) {
		pos = pos || [0, 0];
		scale = scale || 1;
		
		this(count, { 'float2 offs': pos, 'float scale': scale }, `
			Self.new { .ctor(scale * ri2xy(1, i) + offs); }
		`);
		
	},
	
	
	go() {
		const app = this.App.get();
		this.points = new app.tuti.Points({
			data: this,
			extraAttrs: ['dir'],
			inject: { vert: { vars: `attribute vec2 dir;varying vec2 varDir;`, before: `varDir = dir;` } },
			frag: `
				varying   vec3  varColor;
				varying   vec2  varDir;
				varying   vec2  varTcoord;
				varying   float varSize;
				
				void main() {
					vec2 varVel = varDir * 1000000.0;
					varVel.y = -varVel.y;
					
					vec2 dir = 0.5*(gl_PointCoord.xy - vec2(0.5, 0.5));
					float dist = max(0.0, 0.245 - length(dir));
					float dist2 = abs(0.17-dist);
					dist = pow(dist, 20.0)*200000000000000000.0;
					dist2 = pow(dist2, 2.0)*200.0;
					float veldot = min(1.0, max(0.0, dot(normalize(varVel), normalize(dir))));
					float dotinv = min(1.0, max(0.0, pow(veldot-0.98, 1.4)));
					veldot = min(1.0, pow(veldot, 100.0));
					
					veldot = max(0.0, veldot - 200000.0*dotinv);
					dist2 = max(0.0, min(0.3, 0.3-dist2));
					gl_FragColor = vec4(varColor, (1.0+0.1*length(varVel)*veldot)*min(1.0, dist)-max(0.0, dist2));
				}
			`,
		});
	},
	
	
	tick() {
		
		this(`
			
			.size += 5.0f * .food;
			.energy = __saturatef(.energy + .food - 0.001);
			.food = 0.0;
			
			// Normalize actuation
			.forward.value = max(-1.0f, min(1.0f, .forward.value ));
			.right.value = max(-1.0f, min(1.0f, .right.value ));
			.clockwise.value = 0;//max(-1.0f, min(1.0f, .clockwise.value ));
			.fov.value = max(-1.0f, min(1.0f, .fov.value ));
			
			//.fov2 = .fov.value;
			.fov2 = 1.0f;
			
			// Precalculated color
			// float col = __saturatef((.forward.value+1)*0.5);
			// .rgb = { 0.3f + 0.7f * col, 0.3f - 0.3f * col, 0.3f - 0.3f * col };
			// .rgb = t2rgb(0.5f * .energy);
			
			.vel += .dir * 0.05f * .forward.value + make_float2(.dir.y, -.dir.x) * 0.05f * .right.value;
			.pos += .vel;
			.vel *= 0.99;
			
			.dir = Lib.rotate2(.dir, 0.05f * .clockwise.value);
			
			
			
		`);
		
	},
	
	
};
