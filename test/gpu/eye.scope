'use strict';

/**
 * Wisp eye.
 */

module.exports = {
	
	host  : 'Core', // owner
	neuron: 'Ns.Neuron' , // Base neuron
	idx   : 'int'  ,
	
	pos     : 'float2', // позиция
	rgb     : 'float3', // цвет
	size    : 'float',
	
	go() {
		const app = this.App.get();
		this.points = new app.tuti.Points({
			data: this,
			frag: `
				varying vec3  varColor;
				
				void main() {
					
					gl_FragColor = vec4(varColor, 1);
					
				}
			`,
		});
	},
	
	
	
	'void ctor(int host, int neuron, int idx)': `
		.host   = host;
		.neuron = neuron;
		.idx    = idx;
		.pos    = .host.pos;
		.rgb    = { 0.3f, 0.3f, 0.3f };
		.size   = 0.5;
	`,
	
	tick() {
		
		/*
		this.Food(`
			if (.cooldown > 0.01f) {
				return;
			}
			
			// Find FOV bounds
			Core {
				float2 dir2   = ..pos - .pos;
				float    len  = length(dir2);
				dir2         /= len;
				
				float fov       = (.fov2 + 1.0f) / 2.0f;
				
				float dirAngle  = atan2( .dir.y, .dir.x  ) / 2 / 3.1415926;
				float dir2Angle = atan2(  dir2.y, dir2.x ) / 2 / 3.1415926;
				
				float delta     = dirAngle - dir2Angle;
				
				if ( delta < -0.5 ) delta += 1;
				if ( delta >  0.5 ) delta -= 1;
				
				// здесь точно правильно вычислена дельта от -0.5 до +0.5
				// где 0 - это точное совпадение пелинга на food с direct
				// нужно проверить, 
				
				if ( delta > -fov/2 && delta < fov/2 ){
					// ToDo: поворот больше 360
					
					// возможно, формула неверна. проверить (Луису)
					float project   = ( delta + fov*0.5f ) / fov;
					
					int eyeIdx = project * .eyes2.length;
					.eyes2[ eyeIdx ] {
						.neuron.value +== 5.0f / pow(len, 1.3f);
					}
				}
			}
		`);
		*/
		
		
	},
	
	
	debugRgb() {
		this(`
			.rgb = t2rgb(.neuron.value);
		`);
	},
	
	debugPos() {
		this(`
			float fov       = (.host.fov2 + 1.0f) / 2.0f * 6.28f;
			float2 offs = Lib.rotate2(.host.dir*.host.size*0.35f, fov/2 - fov / .host.eyes2.length * 0.5 - fov / .host.eyes2.length * .idx);
			.pos = .host.pos + offs;
		`);
	},
	
	
};
