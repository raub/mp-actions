'use strict';

/* global use */

module.exports = {
	
	
	Perceptron: use('lib/rau/perc'),
	
	Learner: {
		
		synapse: 'PercBrain.Perceptron.PercSynapse',
		core: 'Core',
		cooldown: 'float',
		
		'void ctor(int synapsei, int corei)': `
			.synapse = synapsei;
			.core = corei;
			.cooldown = 0.0f;
		`,
		
	},
	
	
	inject(range, size, color) {
		
		range = range || {};
		range.start = range.start || 0;
		range.end   = range.end   || this.Core.el.count;
		size = size || 10;
		
		// Spawn EYES
		this.Core(range.end - range.start, { 'int start': range.start, 'float r': color[0], 'float g': color[1], 'float b': color[2] }, `
			
			int corei = i + start;
			
			Core[ corei ] {
				
				.rgb = {r,g,b};
				
				for (int j = 0; j < .eyes; j++) {
					PercBrain.Perceptron.PercNeuron.new {
						
						.ctor();
						
						Eye.new {
							.ctor(corei, ..neuron, j);
							...eyes2.push(.);
						}
						
					}
				}
				
			}
			
		`);
		
		
		// Spawn ACTUATORS
		this.Core(range.end - range.start, { 'int start': range.start }, `
			
			int corei = i + start;
			
			Core[ corei ] {
				
				PercBrain.Perceptron.PercNeuron.new {
					.ctor();
					..clockwise = .neuron;
				}
				PercBrain.Perceptron.PercNeuron.new {
					.ctor();
					..forward = .neuron;
				}
				PercBrain.Perceptron.PercNeuron.new {
					.ctor();
					..right = .neuron;
				}
				PercBrain.Perceptron.PercNeuron.new {
					.ctor();
					..fov = .neuron;
				}
				
			}
			
		`);
		
		
		// Connect
		this.Core(range.end - range.start, { 'int start': range.start, 'int size': size }, `
			
			int corei = i + start;
			
			Core[ corei ] {
				
				int outs[4];
				outs[0] = .clockwise;
				outs[1] = .forward;
				outs[2] = .fov;
				outs[3] = .right;
				
				int i2 = .;
				
				// Spawn all hidden neurons
				for (int k = 0; k < size; k++) {
					PercBrain.Perceptron.PercNeuron.new {
						
						.ctor();
						
						// Synapce from eye to current hidden
						..eyes2 {
							PercBrain.Perceptron.PercSynapse.new {
								.ctor(..neuron, ...);
								PercBrain.Learner.new { .ctor(.., i2); }
							}
						}
						
						// Synapce from current hidden to out
						for (int m = 0; m < 4; m++) {
							PercBrain.Perceptron.PercSynapse.new {
								.ctor(.., outs[m]);
								PercBrain.Learner.new { .ctor(.., i2); }
							}
						}
						
						for (int m = 0; m < 4; m++) {
							PercBrain.Perceptron.PercSynapse.new {
								.ctor(outs[m], ..);
								PercBrain.Learner.new { .ctor(.., i2); }
							}
						}
						
					}
				}
				
			}
			
		`);
		
		
		// this.PercBrain.Perceptron.PercSynapse.el.dump('',2);
	},
	
	
	tick() {
		this.Learner(`
			if (.core.energy < 0.001f && .cooldown < 0.01f) {
				.synapse.weight = Random.get() > 0.5f ? -.synapse.weight : .synapse.weight;
				.cooldown = 1.0f;
			}
			.core.rgb = t2rgb(0.5f + .cooldown * 0.5f);
			.cooldown *= 0.97f;
			.synapse.weight = max(-1.0f, min(1.0f, .synapse.weight + .core.food * .synapse.dest.mem ));
		`);
		this.Perceptron.tick();
	},
	
	
};
